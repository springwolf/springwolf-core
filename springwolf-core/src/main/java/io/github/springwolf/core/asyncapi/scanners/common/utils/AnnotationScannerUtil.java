// SPDX-License-Identifier: Apache-2.0
package io.github.springwolf.core.asyncapi.scanners.common.utils;

import io.swagger.v3.oas.annotations.Hidden;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.ReflectionUtils;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Stream;

@Slf4j
public class AnnotationScannerUtil {

    private AnnotationScannerUtil() {}

    public static <A extends Annotation> boolean isClassRelevant(Class<?> clazz, Class<A> annotationClass) {
        log.debug("Scanning class \"{}\" for @\"{}\" annotation", clazz.getName(), annotationClass.getName());
        return AnnotationScannerUtil.isNotHidden(clazz)
                && AnnotationUtil.findAnnotation(annotationClass, clazz) != null;
    }

    public static <A extends Annotation> Stream<MethodAndAnnotation<A>> getRelevantMethods(
            Class<?> clazz, Class<A> annotationClass) {
        log.debug("Scanning class \"{}\" for @\"{}\" annotated methods", clazz.getName(), annotationClass.getName());

        Stream<Method> methods = Arrays.stream(ReflectionUtils.getAllDeclaredMethods(clazz))
                .filter(AnnotationScannerUtil::isMethodInSourceCode)
                .filter(AnnotationScannerUtil::isNotTypicalJavaMethod)
                .filter(AnnotationScannerUtil::isNotHidden);

        if (annotationClass == AllMethods.class) {
            return methods.map(method -> new MethodAndAnnotation<>(method, null));
        }

        return methods.filter(method -> AnnotationUtil.findAnnotation(annotationClass, method) != null)
                .peek(method -> log.debug("Mapping method \"{}\"", method.getName()))
                .flatMap(method -> AnnotationUtil.findAnnotations(annotationClass, method).stream()
                        .map(annotation -> new MethodAndAnnotation<>(method, annotation)));
    }

    /**
     * Internal interface to indicate that all methods of a class should be used in scanners
     * instead of filtering for a specific annotation.
     */
    public @interface AllMethods {}

    public record MethodAndAnnotation<A>(Method method, A annotation) {}

    /**
     * Check that a method was written by a developer and not generated by the compiler.
     */
    private static boolean isMethodInSourceCode(Method method) {
        return !method.isSynthetic();
    }

    private static boolean isNotHidden(AnnotatedElement element) {
        return Objects.isNull(AnnotationUtil.findAnnotation(Hidden.class, element));
    }

    private static final Set<String> typicalJavaMethods =
            Set.of("clone", "equals", "finalize", "getClass", "hashCode", "notify", "notifyAll", "toString", "wait");

    private static boolean isNotTypicalJavaMethod(Method method) {
        return !typicalJavaMethods.contains(method.getName());
    }
}
