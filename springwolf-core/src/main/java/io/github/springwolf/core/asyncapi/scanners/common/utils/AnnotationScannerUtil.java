// SPDX-License-Identifier: Apache-2.0
package io.github.springwolf.core.asyncapi.scanners.common.utils;

import io.swagger.v3.oas.annotations.Hidden;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.ReflectionUtils;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
public class AnnotationScannerUtil {

    private AnnotationScannerUtil() {}

    /**
     * Find all annotated methods on an annotated class
     *
     * Transform is only called if methods are found
     */
    public static <C extends Annotation, M extends Annotation, R> Stream<R> findAnnotatedMethods(
            Class<?> clazz,
            Class<C> classAnnotationClass,
            Class<M> methodAnnotationClass,
            BiFunction<Class<?>, Set<Method>, Stream<R>> transformer) {
        log.debug("Scanning class \"{}\" for @\"{}\" annotation", clazz.getName(), classAnnotationClass.getName());
        Set<Method> methods = Stream.of(clazz)
                .filter(it -> AnnotationScannerUtil.isClassRelevant(it, classAnnotationClass))
                .peek(it -> log.debug("Mapping class \"{}\"", it.getName()))
                .flatMap(it -> AnnotationScannerUtil.findAnnotatedMethods(it, methodAnnotationClass))
                .map(AnnotationScannerUtil.MethodAndAnnotation::method)
                .collect(Collectors.toSet());

        if (methods.isEmpty()) {
            return Stream.empty();
        }

        return transformer.apply(clazz, methods);
    }

    static <A extends Annotation> boolean isClassRelevant(Class<?> clazz, Class<A> annotationClass) {
        return AnnotationScannerUtil.isNotHidden(clazz)
                && AnnotationUtil.findAnnotation(annotationClass, clazz) != null;
    }

    public static <A extends Annotation> Stream<MethodAndAnnotation<A>> findAnnotatedMethods(
            Class<?> clazz, Class<A> methodAnnotationClass) {
        log.debug(
                "Scanning class \"{}\" for @\"{}\" annotated methods",
                clazz.getName(),
                methodAnnotationClass.getName());

        Stream<Method> methods = Arrays.stream(ReflectionUtils.getAllDeclaredMethods(clazz))
                .filter(AnnotationScannerUtil::isMethodInSourceCode)
                .filter(AnnotationScannerUtil::isNotTypicalJavaMethod)
                .filter(AnnotationScannerUtil::isNotHidden);

        if (methodAnnotationClass == AllMethods.class) {
            return methods.peek(method -> log.debug("Mapping method \"{}\"", method.getName()))
                    .map(method -> new MethodAndAnnotation<>(method, null));
        }

        return methods.filter(method -> AnnotationUtil.findAnnotation(methodAnnotationClass, method) != null)
                .peek(method -> log.debug("Mapping method \"{}\"", method.getName()))
                .flatMap(method -> AnnotationUtil.findAnnotations(methodAnnotationClass, method).stream()
                        .map(annotation -> new MethodAndAnnotation<>(method, annotation)));
    }

    /**
     * Internal interface to indicate that all methods of a class should be used in scanners
     * instead of filtering for a specific annotation.
     */
    public @interface AllMethods {}

    public record MethodAndAnnotation<A>(Method method, A annotation) {}

    /**
     * Check that a method was written by a developer and not generated by the compiler.
     */
    private static boolean isMethodInSourceCode(Method method) {
        return !method.isSynthetic();
    }

    private static boolean isNotHidden(AnnotatedElement element) {
        return Objects.isNull(AnnotationUtil.findAnnotation(Hidden.class, element));
    }

    private static final Set<String> typicalJavaMethods =
            Set.of("clone", "equals", "finalize", "getClass", "hashCode", "notify", "notifyAll", "toString", "wait");

    private static boolean isNotTypicalJavaMethod(Method method) {
        return !typicalJavaMethods.contains(method.getName());
    }
}
